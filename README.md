# questions_solver

## Description

QuestionsSolver is a complete website to help students solve old exams using AI.

---

## Table of Contents

- [Development Environment](#development-environment)
  - [DEV: Environment Configuration](#dev-environment-configuration)
    - [Frontend: `.env` File](#frontend-env-file)
    - [Backend: `.env` File](#backend-env-file)
    - [Google Docs configuration](#google-docs-configuration)
  - [DEV: Build and run the containers](#dev-build-and-run-the-containers)
  - [DEV: Install new React dependencies](#dev-install-new-react-dependencies)
- [Production Environment](#production-environment)
  - [PROD: Steps for Flask Backend Deployment on AWS EC2](#prod-steps-for-flask-backend-deployment-on-aws-ec2)
  - [PROD: Stop Services inside instance](#prod-stop-services-inside-instance)
  - [PROD: Start Services inside instance](#prod-start-services-inside-instance)
  - [PROD: Follow logs](#prod-follow-logs)
---

## Development Environment

### DEV: Environment Configuration

To run the application properly, you need to set up environment variables in two separate `.env` files: one for the frontend and one for the backend. Below is a description of the environment variables used in this project.

#### Frontend: `.env` File

The frontend environment variables should be defined in a `.env` file located inside the `/frontend` directory.

- **REACT_APP_ENV**: This variable defines if the environment is `development` or `production`.
- **REACT_APP_REAIS_PER_QUESTION**: This variable defines the amount charged for solving one question of the exam, in Reais (the Brazilian currency).
- **REACT_APP_HUMAN_REVISION_EXTRA**: This variable defines the amount charged for solving with human revision, done by a real student of that subject.

An example of this `.env` file can be found inside the `/frontend` directory, by the name `.env.example`.

#### Backend: `.env` File

The backend environment variables should be defined in a `.env` file located inside the `backend` directory. These variables are necessary for configuring the secure connection to the Pix API and to the Mail API.

- **ENV**: This variable defines if the environment is `development` or `production`.
- Pix API variables:
  - **CLIENT_ID**: The login string for the Pix provider.
  - **CLIENT_SECRET**: The password string for the Pix provider.
  - **KEY_PEM_PATH**: The file path to the certificate required for authentication with the Pix API.
  - **PIX_RECEIVER_KEY**: The receiving key for the desired account to handle Pix transactions.
- Mail API variables:
  - **MAIL_SERVER**: The mail SMTP server.
  - **MAIL_PORT**: The mail port.
  - **MAIL_USE_TLS**: A boolean do define secure TLS mail connection.
  - **MAIL_USERNAME**: The username of the mail account in use.
  - **MAIL_PASSWORD**: The password of the mail account in use. 
  - **MAIL_DEFAULT_SENDER**: The e-mail of the sender account.
  - **MAX_TOKENS_PER_API_CALL**: Maximum number of tokens (words, parts of words, punctuation, etc.) that can be used in a single API request.
  - **API_KEY**: Chat GPT API key.

An example of this `.env` file can be found inside the `/backend` directory, by the name `.env.example`.

#### Google Docs configuration

To configure Google Docs, it is necessary to add 2 files to `/backend/gpt_api/`:
- `credentials.json`
This file is generated by going to `https://console.cloud.google.com/`, creating a project, activating the desired API (in this case Google Docs API) and following the configuration steps.
- `token.pickle`
This file is generated after the first trial of using Python to connect with the API, on which the browser window will open to validate connection. After some time, this token expires, and refresh is needed.


### DEV: Build and run the containers

To build the containers via the ```docker-compose.dev.yml``` file, use the command:

```
docker compose -f docker-compose.dev.yml build --no-cache
```
> The `--no-cache` is recommended to ensure a clear build of the image.

After building, you can start and run the containers with the command:

```
docker-compose -f docker-compose.dev.yml up
```

> This Development Environment allows for hot reloading on the frontend.

### DEV: Install new React dependencies

First, build and let the frontend container run with the previous steps.

After that, manually execute the installation of the dependency inside the frontend container with the command:

```
docker exec -it <container_name_or_id> npm install <name_of_dependence>
```

> Note that it will be needed the name or id of the container, which can be consulted with the command ```docker ps```

> Also note that, by the volumes configuration in the `docker-compose.dev.yml` file, the ```package.json``` and ```package-lock.json``` got updated inside the container as well as in the host.

## Production Environment

### PROD: Steps for Flask Backend Deployment on AWS EC2

- **Create EC2 Instance (check region)**
  - Recommended Ubuntu
  - Check keys
  - Allow HTTP and HTTPS

- **Create Elastic IP**
  - Associate to EC2 Instance

- **Configure Route 53 record to point to the EC2 instance Elastic IP**

- **Connect to EC2 Instance**

- **Configure the instance**

  - **Update and Install Dependencies**
    - `sudo apt-get update && sudo apt-get upgrade -y`
    - `sudo apt install python3-pip python3-venv nginx git -y`

  - **Clone Repository and Set Up Backend**
    - `git clone <your-repo-url> && cd <your-repo-directory>`
    - `git checkout <branch-name> && cd backend`
    - Create `.env`: `sudo nano .env`
    - Set up virtual environment:
      ```bash
      python3 -m venv venv
      source venv/bin/activate
      pip install -r requirements_prod.txt
      ```

  - **Move local files to the instance**
    - The necessary files are:
      - `credentials.json`, `token.pickle`, both located in `/backend/gpt_api/`
      - `certificate.pem`, located in `/backend/pix_api/keys/`
    - Make sure to create the `/keys/` directory in the instance, with `mkdir keys`.
    - Move the files to the instance:
      ```bash
      scp -i /localpath/key.pem /localpath/file ubuntu@ec2-instance-public-ip:/home/ubuntu/questions_solver/backend/
      ```
      > Change for the correct path to the key file and the file to be moved.

    > Note that it may be needed to run `chmod 400 /localpath/key.pem` to ensure the file has the correct permissions.

    > If the followig alert appear "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED", solve it by running `ssh-keygen -R [ec2-instance-public-ip]`

  - **Install Gunicorn and Configure Systemd Service**
    - `pip install gunicorn`
    - Create Gunicorn service: `sudo nano /etc/systemd/system/gunicorn.service`
      ```ini
      [Unit]
      Description=Gunicorn to serve Flask app
      After=network.target

      [Service]
      User=ubuntu
      Group=www-data
      WorkingDirectory=/home/ubuntu/questions_solver/backend
      Environment="PATH=/home/ubuntu/questions_solver/backend/venv/bin"
      ExecStart=/home/ubuntu/questions_solver/backend/venv/bin/gunicorn --workers 3 --bind 127.0.0.1:8000 app:app

      [Install]
      WantedBy=multi-user.target
      ```
    - `sudo systemctl daemon-reload && sudo systemctl start gunicorn && sudo systemctl enable gunicorn`

  - **Configure Nginx**
    - `sudo nano /etc/nginx/sites-available/flask_app`
      ```nginx
      server {
          listen 80;
          server_name api.iloveprovaantiga.com.br;

          location / {
              proxy_pass http://127.0.0.1:8000;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
          }

          client_max_body_size 10M;
      }
      ```
    - `sudo ln -s /etc/nginx/sites-available/flask_app /etc/nginx/sites-enabled`
    - `sudo rm /etc/nginx/sites-enabled/default`
    - Test and reload Nginx:
      ```bash
      sudo nginx -t
      sudo systemctl reload nginx
      ```

  - **Enable SSL with Certbot**
    - `sudo apt-get install certbot python3-certbot-nginx`
    - `sudo certbot --nginx -d api.iloveprovaantiga.com.br`
    > It will be asked for an email and to agree to the terms of service.

  - **Verify Services**
    - `sudo systemctl status gunicorn`
    - `sudo systemctl status nginx`

### PROD: Stop Services inside instance

1. **Stop Gunicorn Service**
```bash
sudo systemctl stop gunicorn
```

2. **Stop Nginx Service**
```bash
sudo systemctl stop nginx
```

3. **Check the Status of Both Services**
```bash
sudo systemctl status gunicorn
sudo systemctl status nginx
```

### PROD: Start Services inside instance

1. **Start Nginx Service**
```bash
sudo systemctl start nginx
```

2. **Start Gunicorn Service**
```bash
sudo systemctl start gunicorn
```

### PROD: Follow logs

1. **View Gunicorn Logs**

Using journalctl for Gunicorn:

```bash
sudo journalctl -u gunicorn
```

This command will show all the logs for the Gunicorn service. You can also use flags like `-f` to follow the logs in real-time:

```bash
sudo journalctl -u gunicorn -f
```

2. **View Nginx Logs**

Nginx logs are typically stored in the following default directories:

- Access Logs (records requests to the server):
  ```bash
  cat /var/log/nginx/access.log
  ```
- Error Logs (records any errors):
  ```bash
  cat /var/log/nginx/error.log
  ```

To follow the Nginx logs in real-time, use:

- For access logs:
```bash
tail -f /var/log/nginx/access.log
```

- For error logs:
```bash
tail -f /var/log/nginx/error.log
```
